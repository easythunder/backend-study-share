# 9-1장 (Optimizer)

# 옵티마이저(Optimizer) 정리

## 1) 옵티마이저란?

- MySQL 서버로 들어온 쿼리는 **결과는 같아도 실행 방법(접근 경로/조인 순서 등)은 여러 가지**가 가능함
- 옵티마이저를 실행하는 엔진은 따로 존재하지 않고 MySQL 서버 (SQL 레이어, MySQㅣ엔진)안에서 쿼리를
처리하는 스레드가 옵티마이저 코드를 호출해서 실행합니다.
> 실행 계획 확인: EXPLAIN
- 이 중 가장 효율적인 실행 계획(Execution Plan)을 선택하는 역할이 **옵티마이저(Optimizer)**
## 예시 1) 같은 결과지만 실행 계획이 달라지는 경우 (인덱스 vs 풀 테이블 스캔)

### 상황
- `users` 테이블에 데이터가 매우 많다고 가정 (예: 1,000만 건)
- `age` 컬럼에 인덱스가 존재 (`INDEX(age)`)

```sql
SELECT *
FROM users
WHERE age >= 20;

실행 계획 후보 (쿼리 결과는 동일)
	•	플랜 A: 인덱스 레인지 스캔(range)
	•	age >= 20에 해당하는 인덱스 범위만 읽어서 조건을 만족하는 행을 찾음
	•	조건에 맞는 데이터가 적을 때 유리 (선택도가 좋을 때)
	•	플랜 B: 풀 테이블 스캔(ALL)
	•	테이블을 처음부터 끝까지 전부 읽고
	•	그 중에서 age >= 20 조건을 만족하는 행만 걸러냄
	•	조건에 맞는 데이터가 너무 많을 때 오히려 유리할 수 있음

옵티마이저가 선택을 바꾸는 대표적인 이유
	•	age >= 20이 전체의 5% 정도라면?
	•	인덱스로 좁게 읽는 게 유리 → 플랜 A(인덱스 range) 선택 가능성이 큼
	•	age >= 20이 전체의 90% 정도라면?
	•	어차피 대부분 읽어야 하고, 인덱스를 타면 랜덤 접근이 늘어 손해일 수 있음
→ 플랜 B(풀 테이블 스캔) 선택 가능성이 커짐

정리
	•	쿼리는 같아도(결과 동일), 조건에 걸리는 비율/데이터 분포에 따라 “가장 싼 실행 방법”이 달라져서 옵티마이저가 실행 계획을 선택한다.
---

## 2) 쿼리 실행 절차 (3단계)

1. **SQL 파서(Parser)**
    - SQL 문장을 분석/분해하여 **SQL 파스 트리(Parse Tree)** 생성
2. **옵티마이저(Optimizer)**
    - 파스 트리를 기반으로 **실행 계획 수립**
3. **MySQL 엔진 + 스토리지 엔진**
    - 실행 계획에 따라 스토리지 엔진에서 데이터를 읽고 처리

---

## 3) 기본 데이터 처리

### 3-1) 리드 어헤드(Read Ahead)

- 앞으로 필요할 데이터를 예측해 **미리 디스크에서 읽어 버퍼 풀(Buffer Pool)에 적재**하는 동작
- 예시 흐름
    - 풀 테이블 스캔 시작 시 초기 일부 페이지는 **포그라운드 스레드**가 읽음
    - 이후 특정 시점부터 읽기 작업을 **백그라운드 스레드**로 넘김
    - 백그라운드 스레드는 한 번에 **4개 또는 8개 페이지**를 읽어 버퍼 풀에 저장(읽는 페이지 수는 점점 증가)
    - 포그라운드 스레드는 버퍼 풀의 준비된 데이터를 사용 → 처리 속도 향상
- 주로 사용되는 경우: **풀 테이블 스캔, 풀 인덱스 스캔**

---

### 3-2) 풀 테이블 스캔(Full Table Scan)

- 테이블을 처음부터 끝까지 전부 읽는 방식
- 발생/선택되는 대표 상황
    - 테이블 레코드 수가 적어서 **인덱스 사용보다 빠른 경우**
    - `WHERE` / `ON` 절에 **인덱스를 사용할 수 있는 조건이 없는 경우**
    - 옵티마이저가 판단한 **예상 조회 건수가 너무 많아** 인덱스 활용이 비효율적인 경우

---

### 3-3) 풀 인덱스 스캔(Full Index Scan)

- 인덱스를 처음부터 끝까지 전부 스캔하는 방식

---

### 3-4) 병렬 처리(Parallel)

- 하나의 쿼리를 **여러 스레드로 나누어 처리**하는 방식
- 조건 없이 단순히 **전체 건수 조회** 같은 쿼리만 병렬 처리 가능
- 실무에서 병렬처리를 쓰는 방법! (GPT 참고)
실무에서 병렬 처리라고 할 때, MySQL은 크게 3가지로 나뉘어서 쓰입니다. 
중요한 포인트는 PostgreSQL처럼 ‘일반 SELECT가 자동으로 멀티코어 병렬 실행’되는 범위는 
MySQL 커뮤니티 버전에선 제한적이라는 점이에요.

*) 실무에서 제일 많이 체감하는 병렬 처리: “복제(Replication) 병렬 적용”

대부분 회사에서 병렬 처리로 가장 많이 튜닝하는 건 이쪽이에요.

Multi-threaded replication applier(병렬 적용 스레드)
	•	레플리카(Replica)가 바이너리 로그 이벤트를 적용할 때 여러 워커(applier) 스레드가 병렬로 적용해서 replication lag을 줄이는 게 핵심입니다.  ￼
	•	MySQL 8.0에서는 writeset 기반 의존성 추적으로 병렬 적용 효율이 좋아졌다는 설명이 많아요.  ￼

실무 사용 시나리오
	•	읽기 트래픽이 레플리카로 많이 가서 “지연(lag)”이 문제일 때
	•	장애 대비(HA) 구성에서 레플리카가 빨리 따라와야 할 때
	•	배치/마이그레이션 후 레플리카 catch-up 속도 올리고 싶을 때