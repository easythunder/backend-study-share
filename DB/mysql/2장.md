# 2장

# 1. 백엔드 개발자 입장에서 MySQL·SQL이 왜 중요한가?

백엔드에서 보통 구조는 이렇게 나뉜다.

- **애플리케이션 코드 (Java/Spring, Node, etc.)**
    - 사용자의 요청 처리
    - 비즈니스 로직 수행 (로그인, 주문, 글쓰기 등)
- **데이터베이스(MySQL)**
    - 회원정보, 게시글, 주문내역 같은 “데이터”를 **안전하게 저장**하는 역할
    - SQL이라는 언어로 데이터를 읽고/쓰기 한다

백엔드 개발자는 크게 두 가지를 알아야 한다.

1. **SQL 문법**
    
    → `SELECT`, `INSERT`, `UPDATE`, `DELETE` 같은 쿼리로 데이터를 다루는 법
    
2. **DB 서버(MySQL) 자체**
    
    → 설치, 버전, 포트, 계정, 문자셋, 설정 파일(`my.cnf`), 업그레이드 방식 등
    

Real MySQL 8.0 2장(설치와 설정) + 해당 velog 글은 특히 **2번(서버·설정·업그레이드)**에 초점을 맞춘 내용이다.

지금은 “내가 직접 서버 업그레이드 할 일은 없는데?” 싶어도, 실무에 가면 **이미 돌아가는 DB**가 거의 항상 있으므로,

이 개념을 미리 알아두면 나중이 훨씬 편하다.

---

# 2. MySQL 업그레이드란? (폰 OS 업데이트랑 비슷한 개념)

MySQL도 **버전**이 있다.

- 예: 5.5, 5.6, 5.7, 8.0 …

**업그레이드** = 기존 MySQL 서버를 더 높은 버전으로 올리는 것.

- 기대 효과
    - 성능 향상
    - 버그 수정
    - 새 기능 추가
- 위험
    - **호환성 문제**: 예전 버전에서 잘 되던 SQL이 새 버전에서 에러 날 수 있음
    - 예: 특정 함수/옵션 제거, 동작 방식 변경, 예약어 추가 등

백엔드 입장에서 자주 나오는 상황:

- 로컬(MySQL 8.0)에서 개발한 SQL → 운영 서버(MySQL 5.7)에서는 안 돌아감
- 혹은 그 반대 상황

그래서 **DB 버전과 업그레이드** 개념을 알고 있어야 한다.

---

# 3. 업그레이드 방식 2가지: 인플레이스 vs 논리적 업그레이드

MySQL 업그레이드에는 대표적으로 두 가지 방식이 있다.

## 3-1. 인플레이스 업그레이드 (In-place upgrade)

> 데이터 파일은 그대로 두고, MySQL 프로그램만 새 버전으로 교체
> 

비유

- *집(데이터 파일)**은 그대로
- 집 안에 있는 **가전/가구(MySQL 프로그램)**만 바꾸는 느낌

**장점**

- 데이터 복사/이동이 거의 없어서 **빠르다**

**단점 / 제약**

- 버전을 **한 번에 확 못 뛰어넘는 경우가 많다**
    - 예: 5.1 → 8.0 바로 X
        
        5.1 → 5.5 → 5.6 → 5.7 → 8.0 이런 식으로 단계별 업그레이드 필요
        
- 각 버전마다 **데이터 파일 구조**가 조금씩 달라서,
    
    **“직전 버전에서만 업그레이드 가능”** 같은 제약이 존재
    

→ 빠르지만, **조건이 까다롭고** 실패하면 복구가 힘들 수 있다.

---

## 3-2. 논리적 업그레이드 (Logical upgrade)

> 데이터를 SQL/텍스트로 덤프 뜬 뒤, 새 버전 MySQL에 그 SQL을 다시 실행해서 넣는 방식
> 

일반적으로 `mysqldump`라는 도구를 사용한다.

비유

- 예전 집에서 짐을 전부 **박스(backup.sql)**에 포장해서
- 새 집(새 MySQL 서버)으로 가져가 박스를 풀고 다시 정리하는 느낌

**장점**

- 버전 차이가 커도 상대적으로 유연하게 업그레이드 가능
- 데이터 구조가 바뀐 경우에도, SQL 레벨에서 다시 생성·입력하기 때문에 안전한 편

**단점**

- 데이터량이 많으면 **덤프 + 복원 시간**이 오래 걸림
- 그동안 서비스를 중단해야 할 가능성이 높다

---

## 3-3. 초보 백엔드 개발자에게 중요한 포인트

지금 단계에서 다 외우기보다는:

- “실무에서 MySQL 버전 바꿀 땐, 단순 설치가 아니라
    
    **데이터 파일/덤프/호환성/다운타임**까지 고려해야 한다”
    
- “인플레이스는 빠르지만 제약이 많고, 논리적 업그레이드는 느리지만 안정적이다”

이 정도 감만 잡고 있으면 충분하다.

---

# 4. MySQL 8.0 업그레이드 시 주의할 것들

8.0으로 올릴 때는 특히 몇 가지를 신경 써야 한다.

## 4-1. 인증 방식 변경

- MySQL 8.0 기본 인증 플러그인이
    
    **`caching_sha2_password`**로 변경되었다.
    
- 예전에는 `mysql_native_password`가 많이 쓰였다.

**백엔드에서 발생하는 문제 예시**

- MySQL 8.0 서버 + 예전 버전 MySQL JDBC 드라이버(커넥터)
    
    → `Authentication plugin 'caching_sha2_password' is not supported` 같은 오류 발생
    

**정리**

- MySQL 8.0 사용 시 **클라이언트/드라이버도 최신 버전**으로 맞춰 주는 게 안전하다.
- 필요하면 계정 생성 시 명시적으로 `mysql_native_password`를 쓰기도 하지만,
    
    새 환경에서는 되도록 **기본값(보안 더 강함)**을 쓰는 추세다.
    

---

## 4-2. 호환성 체크

8.0에서는 이전 버전과 다른 점이 많아서, 미리 테스트가 필요하다.

예시

- 일부 함수/옵션 제거 또는 동작 방식 변경
- `GROUP BY` 사용 시 정렬 관련 동작 변화
- 새 예약어 추가로 인해, 테이블이나 컬럼 이름이 예약어와 충돌

보통 실무에서는

1. 테스트 환경에 8.0 설치
2. 기존 애플리케이션을 붙여서 SQL 실행해 보고
3. 에러나는 SQL/기능을 미리 수정

하는 식으로 미리 호환성을 확인한다.

---

## 4-3. 외래키 이름 길이 제한

- MySQL 8.0에는 **외래키 이름 길이가 64자 제한**이 있다.
- ORM(JPA 등)이 자동으로 외래키 이름을 생성하는 경우
    - 규칙에 따라 이름이 지나치게 길어질 수 있고
    - 이 때문에 테이블 생성 시 에러가 날 수 있음

백엔드 개발에서는

- 엔티티/테이블 이름, 외래키 이름이 너무 길어지지 않도록 신경 쓰거나
- ORM에서 네이밍 전략을 조정하는 식으로 문제를 회피한다.

---

## 4-4. 그 밖의 주의사항 예시

- 인덱스 힌트 사용
    
    → 예전에 튜닝 목적으로 쓰던 인덱스 힌트가 8.0에서는 오히려 성능을 해치기도 함
    
- `GROUP BY ... ASC/DESC` 사용
    
    → 정렬이 필요할 때는 `ORDER BY`를 명확하게 따로 쓰는 것을 권장
    
- 파티션 + 공용 테이블스페이스 등
    
    → 버전별로 가능한/불가능한 설정이 다르니 문서를 확인해야 함
    

지금 단계에서는 “버전이 올라가면 예전 튜닝 코드/쿼리가 독이 될 수도 있다” 정도만 기억해도 충분하다.

---

# 5. MySQL 설정 파일: `my.cnf` 개념

MySQL 서버는 보통 **`my.cnf` (윈도우는 `my.ini`)** 라는 설정 파일을 읽으면서 실행된다.

- 서버가 **기동될 때 한 번** 이 파일을 읽는다.
- 어떤 내용을 설정할까?
    - 포트 번호 (기본 3306)
    - 데이터 저장 디렉터리 위치
    - 기본 문자셋·콜레이션
    - 버퍼 크기, 캐시 크기 등 성능 관련 설정
    - 로깅 여부/경로 등

OS나 설치 방식에 따라 `my.cnf` 위치가 다를 수 있으므로,

**“서버가 실제로 어떤 경로의 my.cnf를 읽는지”** 확인하는 것이 중요하다.

---

## 5-1. `my.cnf` 위치 찾기 예제

터미널에서:

```bash
mysqld --verbose --help | grep -A 1 "my.cnf"

```

- `mysqld --verbose --help`
    - MySQL 서버가 시작할 때 참고하는 설정과 경로들을 쭉 보여주는 명령
- `| grep -A 1 "my.cnf"`
    - 그 중 `my.cnf` 관련 라인과 바로 아래 한 줄(-A 1)만 추려서 확인

이 명령으로:

- “어느 경로의 `my.cnf`를 읽는지”
- 혹은 **여러 경로 중 어디를 찾아보는지**

등을 확인할 수 있다.

---

## 5-2. `my.cnf` 기본 예시

예를 들어, 아래와 비슷한 내용이 있을 수 있다.

```
[mysqld]
port = 3306
character-set-server = utf8mb4
collation-server = utf8mb4_general_ci

[client]
default-character-set = utf8mb4

```

- `[mysqld]`
    - MySQL 서버 데몬(`mysqld`)의 설정 섹션
- `port = 3306`
    - MySQL 서버가 열어두는 포트
- `character-set-server`
    - 서버 전체의 기본 문자셋
- `[client]`
    - `mysql` 같은 클라이언트 프로그램의 기본 설정

**백엔드(Spring Boot 예)**

```yaml
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/myapp?characterEncoding=utf8&serverTimezone=Asia/Seoul
    username: root
    password: (비밀번호)

```

여기서:

- `localhost:3306` → `my.cnf`의 `port`와 연결
- `characterEncoding` → 문자셋 설정과 연결
- `serverTimezone` → MySQL 서버의 time_zone과 관계

즉, **MySQL 설정(`my.cnf`)과 애플리케이션 설정(yml/properties)이 서로 맞물려 돌아간다.**

---

# 6. 시스템 변수(System Variables) 개념

MySQL에는 서버의 동작을 제어하는 **시스템 변수**들이 있다.

예시

- `max_connections` : 동시에 허용 가능한 연결 수(접속 가능한 클라이언트 수)
- `innodb_buffer_pool_size` : InnoDB 버퍼 풀 크기 (성능과 직결)
- `character_set_server` : 서버 기본 문자셋
- `time_zone` : 서버 시간대

이 변수들은 다음과 같이 나눌 수 있다.

## 6-1. GLOBAL vs SESSION

- **GLOBAL 변수**
    - MySQL **서버 전체**에 영향을 미치는 설정
    - 예: `max_connections`, `character_set_server`, `innodb_buffer_pool_size` 등
- **SESSION 변수**
    - *각 클라이언트 연결(세션)**마다 따로 가질 수 있는 값
    - 예: `time_zone`, `sql_mode`, `character_set_client` 등

비유

- GLOBAL : 빌딩 전체의 기본 온도
- SESSION : 내 방(각 연결)의 에어컨 온도

---

## 6-2. 정적(static) vs 동적(dynamic)

시스템 변수는 또 이렇게 나뉜다.

- **정적 변수**
    - 서버가 **실행 중일 때는 변경할 수 없는 변수**
    - 값을 바꾸려면:
        1. `my.cnf` 수정
        2. MySQL 서버 재시작
- **동적 변수**
    - 서버가 실행 중일 때도 `SET` 명령으로 값을 바꿀 수 있는 변수
    - 예: `max_connections`, `time_zone` 등 많은 변수들이 여기에 속함

---

## 6-3. 시스템 변수 조회 예제

MySQL 접속 후(`mysql -u root -p`) 아래 명령 실행:

```sql
-- GLOBAL 변수 조회
SHOW GLOBAL VARIABLES LIKE 'time_zone';
SHOW GLOBAL VARIABLES LIKE 'character_set_server';

-- SESSION 변수 조회
SHOW SESSION VARIABLES LIKE 'time_zone';
SHOW SESSION VARIABLES LIKE 'character_set_client';

```

- GLOBAL 값과 SESSION 값이 다를 수도 있다.
- 하나의 서버에서 각 연결마다 다른 설정을 가질 수 있다는 걸 느껴보면 된다.

---

# 7. `SET`, `SET GLOBAL`, `SET SESSION`, `SET PERSIST`, `RESET PERSIST`

## 7-1. `SET GLOBAL`로 동적 변수 바꾸기

예를 들어, `max_connections`를 바꿔 보고 싶다면:

```sql
SHOW GLOBAL VARIABLES LIKE 'max_connections';

```

값을 확인한 뒤,

```sql
SET GLOBAL max_connections = 200;

```

다시 확인:

```sql
SHOW GLOBAL VARIABLES LIKE 'max_connections';

```

→ 이제 200으로 보일 것이다.

**중요 포인트**

- `SET GLOBAL`은 **현재 실행 중인 서버**에만 적용된다.
- MySQL 서버를 **재시작**하면, 다시 `my.cnf`에 적힌 값(혹은 기본값)으로 돌아간다.
- 즉, **“지금만 임시로 바꾸는 느낌”**이다.

---

## 7-2. `SET SESSION` 예시

현재 세션(지금 접속한 연결)에서만 `time_zone`을 바꾸고 싶다면:

```sql
SET SESSION time_zone = '+09:00';

```

- 이 세션에서만 적용되고,
- 연결을 끊으면 (다시 접속하면) 원래 값으로 돌아온다.

---

## 7-3. `SET PERSIST` – “지금 + 다음에도 유지”

`SET PERSIST`는 다음 두 가지를 동시에 한다.

1. 지금 실행 중인 서버에 **즉시 적용**
2. 내부적으로 별도 “자동 설정 파일”에 기록하여
    
    서버 재시작 후에도 그 값이 적용되게 함
    

예제:

```sql
SET PERSIST max_connections = 220;

```

이렇게 하면:

- 현재 서버의 `max_connections`가 220으로 바뀐다.
- 서버를 껐다 켜도 220 값이 유지된다.

정리하자면:

- `SET GLOBAL` : 지금만, 재시작하면 사라짐
- `SET PERSIST` : 지금 + 다음에도 유지(실질적으로 “영구 설정” 같은 효과)

---

## 7-4. `RESET PERSIST` – PERSIST 설정 되돌리기

잘못된 PERSIST 설정을 여러 개 해버렸을 때는:

```sql
RESET PERSIST;

```

이 명령으로 PERSIST로 저장된 설정들을 초기화할 수 있다.

- 위험한 설정이 있거나, 상태를 깔끔하게 초기화하고 싶을 때 쓴다.
- 이 경우 다시 `my.cnf` 설정이나 기본값을 기준으로 서버가 올라온다고 생각하면 된다.

---

# 8. 논리적 업그레이드 예제 (`mysqldump`)

논리적 업그레이드는 “데이터를 SQL로 뽑아서 새 서버에 넣는 방식”이다.

## 8-1. 기존 서버에서 전체 덤프 뜨기

```bash
mysqldump -u root -p --all-databases > backup.sql

```

- `backup.sql` 파일 안에는
    - `CREATE DATABASE`, `CREATE TABLE`, `INSERT ...` 같은 SQL들이 잔뜩 들어 있음
- 이 파일이 바로 **모든 DB의 논리적인 백업**이다.

## 8-2. 새 MySQL 8.0 서버에 복원하기

```bash
mysql -u root -p < backup.sql

```

- `backup.sql`의 SQL들이 순서대로 실행되며
- 새 서버에 DB/테이블/데이터가 그대로 생성된다.

이 흐름이 바로 **논리적 업그레이드**의 기본이다.

---

# 9. 간단 SQL + 문자셋 확인 예제

이제 설정 이야기를 했으니, 아주 간단한 SQL 예제를 한 번 써 보자.

## 9-1. 데이터베이스 생성 (문자셋 지정)

```sql
CREATE DATABASE myapp
  CHARACTER SET utf8mb4
  COLLATE utf8mb4_general_ci;

USE myapp;

```

- `CHARACTER SET utf8mb4`
    - DB 내부 기본 문자셋
- 서버 전체 문자셋(`character_set_server`)과 맞춰주는 게 일반적이다.

## 9-2. 테이블 생성 + 데이터 삽입 + 조회

```sql
CREATE TABLE users (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(50),
    email VARCHAR(100)
);

INSERT INTO users (name, email)
VALUES ('홍길동', 'hong@example.com');

SELECT * FROM users;

```

- 한글이 깨지지 않고 잘 보이면,
    
    `my.cnf` 문자셋 설정과 DB 문자셋이 제대로 잡혀 있다고 볼 수 있다.
    

---

# 10. 정리 – 지금까지 내용 핵심만 다시 한 번

1. **백엔드와 DB**
    - 백엔드는 로직 담당, MySQL은 데이터 저장 담당
    - SQL로 둘을 연결
2. **업그레이드 방식**
    - 인플레이스: 데이터 파일 그대로, 프로그램만 교체 (빠르지만 제약 많음)
    - 논리적: `mysqldump`로 뽑아 새 서버에 넣기 (느리지만 안정적)
3. **MySQL 8.0 주의사항**
    - 기본 인증 플러그인 변경(`caching_sha2_password`) → 드라이버 버전 맞추기
    - 외래키 이름 길이 제한, 호환성 이슈 등
4. **설정 파일 `my.cnf`**
    - 서버 기동 시 한 번 읽는 핵심 설정 파일
    - 포트, 문자셋, 경로, 버퍼 크기 등을 설정
    - `mysqld --verbose --help | grep "my.cnf"`로 위치 확인 가능
5. **시스템 변수**
    - GLOBAL vs SESSION
    - 정적 vs 동적
    - `SHOW GLOBAL/SESSION VARIABLES`로 조회
6. **값 변경**
    - `SET GLOBAL` : 지금만
    - `SET SESSION` : 현재 연결만
    - `SET PERSIST` : 지금 + 재시작 후에도 유지
    - `RESET PERSIST` : PERSIST 설정 초기화
7. **논리적 업그레이드**
    - `mysqldump --all-databases > backup.sql`
    - `mysql < backup.sql`로 새 서버에 복원
8. **기초 SQL**
    - DB/테이블 생성 → 데이터 삽입 → SELECT로 확인