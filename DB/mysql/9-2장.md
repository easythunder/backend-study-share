# 9-2장

### 9.2.3 ORDER BY 처리(Using filesort)

정렬은 크게 2가지:

- **인덱스 정렬**: 읽기 빠름(이미 정렬된 순서로 읽음) / 대신 쓰기(INSERT/UPDATE/DELETE) 비용과 인덱스 공간 증가
- **Filesort 정렬**: 인덱스 없이 실행 시점에 정렬 / 데이터 많을수록 느려질 수 있음
    - 실행 계획 Extra에 `Using filesort`로 확인

**소트 버퍼(Sort buffer)**

- MySQL이 정렬용으로 쓰는 세션 메모리
- 버퍼보다 정렬 대상이 크면 “조각내 정렬 + 디스크 임시 저장 + 병합”이 발생
- 소트 버퍼를 무작정 키우면 세션별 메모리 사용이 커져 OOM 위험

**정렬 알고리즘**

- 싱글 패스: 레코드 전체를 소트 버퍼에 (메모리 많이 필요)
- 투 패스: 정렬 키만 들고 정렬 후, 다시 레코드를 읽어옴(테이블 2번 읽기)
- 투 패스가 되는 경우: 레코드가 `max_length_for_sort_data`보다 크거나, BLOB/TEXT가 SELECT에 포함될 때

**ORDER BY 처리 방식(일반적으로 아래로 갈수록 느림)**

1. 인덱스 사용 정렬
2. 드라이빙 테이블만 filesort 후 조인(Using filesort)
3. 조인 결과를 임시 테이블로 저장 후 정렬(Using temporary; Using filesort)

**LIMIT의 착각**

- ORDER BY / GROUP BY는 “정렬/그룹핑 완료 후” LIMIT 적용이라, LIMIT만으로 작업량이 줄지 않을 수 있음
- 인덱스 정렬은 스트리밍에 가깝고, filesort/임시테이블은 버퍼링 성격이 강함

### 9.2.4 GROUP BY 처리

- GROUP BY도 스트리밍이 어렵고, 인덱스 사용 여부가 핵심

**(1) 타이트 인덱스 스캔**

- 드라이빙 테이블의 GROUP BY 컬럼에 인덱스가 있으면, 인덱스를 순서대로 읽으며 그룹핑 수행 후 조인

**(2) 루스 인덱스 스캔(Using index for group-by)**

- 인덱스 레코드를 “건너뛰며” 필요한 값만 읽는 방식
- MySQL에서는 **단일 테이블 GROUP BY**에서만 적용
- 글의 예시처럼 (emp_no, from_date) 인덱스를 이용해 emp_no를 순서대로 훑고, 각 emp_no에 대해 from_date 조건만 골라 읽는 식으로 동작

**(3) 임시 테이블**

- 인덱스로 그룹핑이 안 되면, GROUP BY 컬럼으로 유니크 인덱스를 가진 내부 임시 테이블을 만들어 중복 제거/집계를 처리

### 9.2.5 DISTINCT 처리

- `SELECT DISTINCT ...`는 내부적으로 **GROUP BY와 유사하게 처리**될 수 있음
- DISTINCT는 “특정 컬럼 하나”가 아니라 **SELECT 결과(튜플)의 유니크**를 의미
- 집합 함수 안의 DISTINCT는 “함수 인자로 들어간 값”의 유니크에만 영향
- 집합 함수 + DISTINCT는 임시 테이블을 쓰더라도 실행 계획에 표시되지 않을 수 있음
- 인덱스된 컬럼의 DISTINCT는 임시 테이블 없이 인덱스 스캔/레인지 스캔으로 최적화 가능 [o](https://velog.io/%40j2yun__/Real-MySQL-8.0-9%EC%9E%A5-%EC%98%B5%ED%8B%B0%EB%A7%88%EC%9D%B4%EC%A0%80%EC%99%80-%ED%9E%8C%ED%8A%B8-9.1-9.2)

### 9.2.6 내부 임시 테이블(Internal Temporary Table)

- MySQL 엔진이 정렬/그룹핑을 위해 내부적으로 만드는 임시 테이블
- `CREATE TEMPORARY TABLE`로 만드는 사용자 임시 테이블과는 다름
- 메모리에 만들었다가 커지면 디스크로 넘어가며, 쿼리 종료 시 자동 삭제/외부에서 조회 불가

**MySQL 8.0의 내부 임시 테이블 엔진**

- 메모리 임시 테이블: TempTable 엔진
- 디스크 임시 테이블: InnoDB
- 관련 변수 예: `temptable_max_ram`, `temptable_use_mmap`

**임시 테이블이 자주 필요한 경우(대표)**

- ORDER BY와 GROUP BY 컬럼이 다름
- ORDER BY/GROUP BY 컬럼이 “조인 순서상 첫 테이블”이 아님
- DISTINCT + ORDER BY 조합(그리고 DISTINCT가 인덱스로 처리되지 못함)
- UNION / UNION DISTINCT
- 실행계획 select_type = DERIVED

---

## 정리

- 옵티마이저는 통계와 비용을 바탕으로 실행 계획을 고르고,
- 정렬/그룹핑/중복제거는 인덱스를 타면 빠르지만, 못 타면 filesort·임시테이블 같은 비용이 커지는 처리로 넘어간다.