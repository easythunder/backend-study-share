# 8-2

7) MySQL 8.0 인덱스 스킵 스캔(Skip Scan)

- 복합 인덱스가 (A, B)인데 **WHERE에서 B만 조건으로 걸리는 경우**, 원래는 인덱스를 제대로 타기 어렵다.
- MySQL 8.0은 조건에 따라 **선행 컬럼 A의 가능한 값들을 “가정”해서 여러 번 범위 탐색**을 수행하는 방식으로 Skip Scan을 활용할 수 있다.
- 핵심 제약/포인트
    - 선행 컬럼(A)의 값 종류가 **적을수록 유리**(예: 성별처럼 M/F)
    - 보통 **커버링 인덱스일 때 효과가 좋고(혹은 요구)**, 테이블 랜덤 접근이 많아지면 이득이 줄어든다
    - 옵티마이저 설정(예: optimizer_switch)로 on/off 및 플랜 확인이 필요

---

## 8) 정렬(ASC/DESC)과 스캔 방향

- 8.0부터는 인덱스 생성 시 **ASC/DESC 방향을 명시**할 수 있고, ORDER BY에 맞춰 인덱스를 설계하는 선택지가 늘었다.
- 주의점
    - 오름차순 인덱스를 **역순으로 읽는 것**이 항상 공짜가 아니고, 상황에 따라 성능 차이가 날 수 있다.
    - DESC 정렬이 “자주” 나오면 DESC 인덱스를 고려할 만하지만, “가끔”이면 굳이 인덱스를 늘리지 않는 판단도 가능.

---

## 9) 복합 인덱스 컬럼 순서가 성능을 결정

- 같은 조건이라도 인덱스 컬럼 순서에 따라:
    - 어떤 조건은 **작업 범위를 줄이는 조건(range를 결정)**이 되고,
    - 어떤 조건은 **나중에 걸러내는 조건(필터)**로만 쓰일 수 있다.
- 기본 규칙(중요)
    - B-Tree는 **왼쪽(선행) 컬럼 기준으로 정렬**된다.
    - 그래서 복합 인덱스는 “선행 컬럼이 WHERE/정렬/그룹 기준에 얼마나 강하게 기여하는가”가 핵심.
- 실전 감각
    - `=`(동등) 조건이 자주 걸리는 컬럼을 앞쪽에 두고,
    - 그 다음에 범위(>, >=, BETWEEN), 정렬(ORDER BY), 그룹(GROUP BY)에 영향을 주는 컬럼을 배치하는 방식이 일반적으로 유리하다.

---

## 10) 인덱스를 ‘범위 결정’으로 못 쓰는 대표 패턴

- NOT 계열: `<>`, `NOT IN`, `NOT BETWEEN`, `IS NOT NULL`
- LIKE 앞 와일드카드: `LIKE '%abc'`
- 인덱스 컬럼에 가공이 들어가는 경우:
    - 함수 적용: `WHERE DATE(col)=...`
    - 연산 적용: `WHERE col+1=...`
- 비교 과정에서 문제가 생기는 경우:
    - 타입 변환이 필요한 비교(문자↔숫자 등)
    - 콜레이션 불일치
    - 비결정적 함수 사용 등
- 포인트: 이런 패턴은 인덱스가 있어도 “검색 범위를 못 줄여서” 결국 많은 페이지를 읽게 된다.

---

## 한 줄 결론

- 7~11장은 “B-Tree가 실제로 **어떻게 읽히고**, 어떤 조건에서 **플랜이 망가지며**, 복합 인덱스의 **컬럼 순서/정렬 방향**이 성능을 좌우한다”가 핵심이다.
- 즉, 인덱스는 개수보다 **쿼리 패턴에 맞는 순서/조건 형태**가 더 중요하다.