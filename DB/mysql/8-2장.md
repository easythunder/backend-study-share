# 8-2

7) MySQL 8.0 인덱스 스킵 스캔(Skip Scan)

- 복합 인덱스가 (A, B)인데 **WHERE에서 B만 조건으로 걸리는 경우**, 원래는 인덱스를 제대로 타기 어렵다.
- MySQL 8.0은 조건에 따라 **선행 컬럼 A의 가능한 값들을 “가정”해서 여러 번 범위 탐색**을 수행하는 방식으로 Skip Scan을 활용할 수 있다.
- 핵심 제약/포인트
    - 선행 컬럼(A)의 값 종류가 **적을수록 유리**(예: 성별처럼 M/F)
    - 보통 **커버링 인덱스일 때 효과가 좋고(혹은 요구)**, 테이블 랜덤 접근이 많아지면 이득이 줄어든다
    - 옵티마이저 설정(예: optimizer_switch)로 on/off 및 플랜 확인이 필요

---

## 8) 정렬(ASC/DESC)과 스캔 방향

- 8.0부터는 인덱스 생성 시 **ASC/DESC 방향을 명시**할 수 있고, ORDER BY에 맞춰 인덱스를 설계하는 선택지가 늘었다.
- 주의점
    - 오름차순 인덱스를 **역순으로 읽는 것**이 항상 공짜가 아니고, 상황에 따라 성능 차이가 날 수 있다.
    - DESC 정렬이 “자주” 나오면 DESC 인덱스를 고려할 만하지만, “가끔”이면 굳이 인덱스를 늘리지 않는 판단도 가능.

---

## 9) 복합 인덱스 컬럼 순서가 성능을 결정

- 같은 조건이라도 인덱스 컬럼 순서에 따라:
    - 어떤 조건은 **작업 범위를 줄이는 조건(range를 결정)**이 되고,
    - 어떤 조건은 **나중에 걸러내는 조건(필터)**로만 쓰일 수 있다.
- 기본 규칙(중요)
    - B-Tree는 **왼쪽(선행) 컬럼 기준으로 정렬**된다.
    - 그래서 복합 인덱스는 “선행 컬럼이 WHERE/정렬/그룹 기준에 얼마나 강하게 기여하는가”가 핵심.
- 실전 감각
    - `=`(동등) 조건이 자주 걸리는 컬럼을 앞쪽에 두고,
    - 그 다음에 범위(>, >=, BETWEEN), 정렬(ORDER BY), 그룹(GROUP BY)에 영향을 주는 컬럼을 배치하는 방식이 일반적으로 유리하다.

Q : 복합 인덱스 사용예시

A : # 복합 인덱스(Composite Index) 사용 예시 정리

복합 인덱스는 자주 같이 쓰는 조건(WHERE) + 정렬(ORDER BY) + 그룹(GROUP BY) 을 한 번에 처리하려고 만든다.  
핵심은 B-Tree는 왼쪽(선행) 컬럼부터 정렬/탐색한다는 점이다.

---

## 예시 1) `=` + 범위 + 정렬 (가장 흔한 패턴)

### 쿼리
```sql
SELECT *
FROM orders
WHERE user_id = 100
  AND created_at >= '2025-12-01'
ORDER BY created_at DESC
LIMIT 20;

### 추천 인덱스
'''sql
CREATE INDEX idx_orders_user_created ON orders(user_id, created_at);

이유
	•	user_id = 100 으로 먼저 범위를 확 줄이고
	•	그 안에서 created_at으로 범위 조건 + 정렬까지 자연스럽게 처리 가능
→ 레인지 스캔에 유리하고 정렬 비용(filesort)도 줄어들 수 있음

---

## 10) 인덱스를 ‘범위 결정’으로 못 쓰는 대표 패턴

- NOT 계열: `<>`, `NOT IN`, `NOT BETWEEN`, `IS NOT NULL`
- LIKE 앞 와일드카드: `LIKE '%abc'`
- 인덱스 컬럼에 가공이 들어가는 경우:
    - 함수 적용: `WHERE DATE(col)=...`
    - 연산 적용: `WHERE col+1=...`
- 비교 과정에서 문제가 생기는 경우:
    - 타입 변환이 필요한 비교(문자↔숫자 등)
    - 콜레이션 불일치
    - 비결정적 함수 사용 등
- 포인트: 이런 패턴은 인덱스가 있어도 “검색 범위를 못 줄여서” 결국 많은 페이지를 읽게 된다.

---

## 한 줄 결론

- 7~11장은 “B-Tree가 실제로 **어떻게 읽히고**, 어떤 조건에서 **플랜이 망가지며**, 복합 인덱스의 **컬럼 순서/정렬 방향**이 성능을 좌우한다”가 핵심이다.
- 즉, 인덱스는 개수보다 **쿼리 패턴에 맞는 순서/조건 형태**가 더 중요하다.

Q : 인덱스를 잘못사용해서 개선한 적이 있나요?
A: 직접 DB를 운영한게 아니라 경험은 없지만 자주 쓰이는 오류 패턴이 있습니다.

케이스: “기간별 목록 조회”가 느려서 인덱스 순서를 바꿔 개선

1) 상황

orders 테이블에서 “특정 유저의 최근 주문 20개”를 자주 조회.
'''sql
SELECT *
FROM orders
WHERE user_id = 100
  AND created_at >= '2025-12-01'
ORDER BY created_at DESC
LIMIT 20;

### 잘못된 인덱스

'''sql
CREATE INDEX idx_orders_created_user ON orders(created_at, user_id);

왜 느려질까?
	•	인덱스가 created_at 기준으로 먼저 정렬돼 있으니까
“12월 이후 주문” 범위를 먼저 쭉 읽고,
	•	그 중에서 user_id=100인 것만 나중에 필터링하게 됨
→ 읽는 양이 커지고, ORDER BY + LIMIT도 기대만큼 빨라지지 않음(사용자별로 못 좁히니까).

### 개선된 커리
쿼리 패턴의 핵심은 “user_id로 먼저 줄이기”야. 그래서 인덱스를 이렇게 바꿈!

'''sql
DROP INDEX idx_orders_created_user ON orders;
CREATE INDEX idx_orders_user_created ON orders(user_id, created_at);

개선되는 이유
	•	user_id=100으로 먼저 범위를 확 줄이고
	•	그 안에서 created_at 범위 조건 + 정렬까지 자연스럽게 처리
→ 레인지 스캔이 짧아지고, LIMIT 20을 빨리 채워서 멈출 수 있음.