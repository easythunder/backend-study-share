# 8-1장 (Index)

# 8장 인덱스 - B-Tree

## 0) 디스크 I/O가 성능의 핵심

- DB가 느린 가장 흔한 원인: **디스크 I/O**
- HDD vs SSD
    - HDD는 플래터/헤드 이동이 필요 → **랜덤 I/O가 특히 느림**
    - SSD는 플래시 메모리 기반 → 랜덤 I/O에서 HDD 대비 훨씬 유리
- 순차 I/O vs 랜덤 I/O
    - 순차 I/O는 여러 페이지를 “한 번에” 처리 가능
    - 랜덤 I/O는 페이지 수만큼 시스템 콜이 늘어 비용 증가
- 쿼리 튜닝으로 랜덤 I/O를 순차 I/O로 바꾸는 건 한계가 큼 → 결국 인덱스 설계/쿼리 설계가 중요

---

## 1) 인덱스 기본 개념

- 인덱스 ≈ **정렬된 목록(Sorted List)**
데이터 파일(테이블)은 ≈ **정렬되지 않은 저장(ArrayList 느낌)**
- 분류
    - **클러스터드 인덱스(= PK)** vs **세컨더리(보조) 인덱스**
    - **유니크 인덱스**: “동등 조건에서 1건만 찾으면 되는지”를 옵티마이저가 판단하는 데 도움
- 대표 구현: B-Tree / Hash (이 글은 B-Tree 중심)

Q : Hash는 언제사용하나요?
A : 해시는 '=' 같다 찾기만 있을때 사용합니다. 범위/정렬은 거의 안됩니다.
키가 매우 유니크하고, 한번에 몇 건만 찾는 패턴에 자주 쓰입니다.

---

## 2) B-Tree 인덱스 구조 (InnoDB 관점 포함)

- B-Tree(계열: B+Tree, B*Tree 포함)는 **항상 정렬 상태 유지**
- 구성: **루트(Root) → 브랜치(Branch) → 리프(Leaf)**
- InnoDB 특징
    - **PK가 ROWID 역할**(각 행의 고유 식별자)
    - **세컨더리 인덱스는 PK를 “주소처럼” 사용**(논리적 주소)
- 레코드는 삭제로 생긴 빈 공간을 재사용할 수 있어, 항상 INSERT 순서대로만 저장되진 않음

---

## 3) 변경(쓰기) 비용: 추가/삭제/변경

### 3.1 인덱스 키 추가(INSERT)

- 리프 노드가 꽉 차면 **Split** 발생 → 상위 브랜치까지 영향 → **쓰기 비용 큼**
- InnoDB는 일반 인덱스 키 추가를 지연 처리할 수 있음
단, **PK/유니크 인덱스는 중복 체크 때문에 즉시 처리**

### 3.2 인덱스 키 삭제(DELETE)

- 즉시 제거가 아니라 **삭제 마크**만 남겨 재활용
- 디스크 쓰기 작업이라 버퍼링되어 지연 처리될 수 있음

### 3.3 인덱스 키 변경(UPDATE)

- 정렬 특성 때문에 자리 이동이 필요 → 내부적으로 **삭제 + 추가**로 처리
- 비용이 커서 **체인지 버퍼**로 지연 처리될 수 있음

---

## 4) InnoDB에서 인덱스 설계가 더 중요한 이유(락)

- InnoDB는 UPDATE/DELETE 시 **검색에 사용된 인덱스에 락을 걸고** 진행
- 넥스트 키 락(레코드 락 + 갭 락) 특성상, 인덱스가 부적절하면 **불필요하게 많은 레코드가 잠길 수 있음**
- 결론: InnoDB에서는 “성능”뿐 아니라 “락 범위” 때문에 인덱스 설계 영향이 매우 큼

---

## 5) B-Tree 성능에 영향을 주는 요소

### 5.1 인덱스 키 크기

- InnoDB는 페이지(기본 16KB)에 인덱스를 담음
- 키가 커질수록 한 페이지에 담는 엔트리가 줄어 **I/O 증가 + 버퍼풀 효율 감소**

### 5.2 B-Tree 깊이(Depth)

- 깊이가 커질수록 루트→브랜치→리프까지 더 많은 페이지 접근 필요(랜덤 I/O 증가)
- 결론: 가능하면 **키를 작게 설계**

### 5.3 선택도 / 기수성(Cardinality)

- 유니크 값이 적고 중복이 많을수록(= cardinality 낮을수록)
조건 1건을 찾기 위해 **추가로 읽는 레코드가 늘어 비효율**

### 5.4 읽어야 하는 레코드 건수(손익분기)

- 인덱스를 타는 게 항상 이득은 아님
- 일반적으로 **전체의 20~25% 정도**가 손익분기점으로 언급됨

---

## 6) B-Tree로 데이터를 읽는 방식(개요)

### 6.1 인덱스 레인지 스캔(Index Range Scan)

- 조건 시작점을 찾고, 리프 노드를 필요한 만큼 순차적으로 읽음
- 이후 (필요 시) 레코드 페이지를 읽어 최종 레코드를 가져옴
- **커버링 인덱스**면 테이블(레코드) 접근을 생략 가능

### 6.2 인덱스 풀 스캔(Index Full Scan)

- 인덱스를 처음부터 끝까지 읽음
- 복합 인덱스 (A,B,C)에서 B나 C만으로 조회하면
선행 컬럼이 없어 탐색이 어려워 풀 스캔이 될 수 있음

### 6.3 루스 인덱스 스캔(Loose Index Scan)

- “듬성듬성” 읽는 방식 (다른 DBMS의 인덱스 스킵 스캔과 유사)
- 구체 조건은 다른 장에서 다룬다고 언급

### 최종 정리!

- 인덱스(B-Tree)는 “정렬된 구조”를 이용해 검색을 빠르게 만들지만, 그 대가로 **쓰기(INSERT/UPDATE/DELETE) 비용**이 커진다.
- InnoDB에서는 특히 **세컨더리 인덱스가 PK를 주소처럼 참조**하고, UPDATE/DELETE 시 **인덱스 기반으로 락(넥스트키 락 등)**이 걸리므로 인덱스 설계가 성능뿐 아니라 **동시성(잠금 범위)**에도 직접 영향을 준다.
- 성능은 결국 디스크 I/O(특히 랜덤 I/O)를 얼마나 줄이느냐가 핵심이며, B-Tree 효율은 **키 크기(작을수록 유리)**, **트리 깊이(얕을수록 유리)**, **기수성/선택도(높을수록 유리)**, 그리고 인덱스 사용 손익분기(대량 조회 시 테이블 스캔이 나을 수 있음)에 의해 좌우된다.