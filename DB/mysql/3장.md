# 3장

# 1. 왜 “사용자 & 권한”이 중요한가?

백엔드 서비스에서는 보통 이런 계정들이 같은 DB에 접속한다.

- 개발자가 쓰는 **개발용 계정**
- 애플리케이션이 사용하는 **서비스 계정**
- DBA / 운영자가 사용하는 **관리자 계정**

이걸 전부 `root` 하나로만 쓰면:

- 실수로 `DROP DATABASE` 같은 걸 해도 막을 수 없다.
- 다른 팀이 남의 테이블을 잘못 건드릴 수 있다.
- 계정이 털리면 DB 전체가 노출된다.

그래서 MySQL은:

- **누가(`user`)**
- **어디서(`host` – IP/호스트)** 접속하는지,
- 그 사람이 **무엇을 할 수 있는지(권한)**

를 아주 세세하게 나눠서 관리한다.

---

# 2. MySQL에서 사용자 식별: `'user'@'host'`

MySQL은 “아이디”만 보는 게 아니라 **접속하는 호스트(IP)까지 포함**해서 사용자 계정을 구분한다.

형식:

```
'아이디'@'호스트'
예) 'svc_id'@'127.0.0.1'
    'svc_id'@'%'

```

- `'svc_id'@'127.0.0.1'`
    - 로컬(127.0.0.1)에서만 접속 가능
- `'svc_id'@'%'`
    - 어디서든(모든 IP) 접속 가능

중요 포인트:

- 같은 아이디라도 `@'127.0.0.1'`, `@'%'`는 **서로 다른 계정**이다.
- MySQL은 여러 계정이 매칭되면 **“가장 구체적인(host가 좁은)” 계정**을 우선 적용한다.
    
    → `'svc_id'@'127.0.0.1'` vs `'svc_id'@'%'` 가 동시에 있고 127.0.0.1에서 접속하면, 앞의 계정이 우선.
    

백엔드에서 자주 쓰는 패턴 예:

- 로컬 개발용: `'dev_user'@'127.0.0.1'`
- 서버에서만 쓰는 서비스 계정: `'app_user'@'서버IP'`
- 어디서든 접속 가능한 관리자: `'admin'@'%'`

- Question? 'dev_user'@'127.0.0.1' 계정과 'dev_user'@'localhost' 계정을 mysql에서 같다고 인식하나요?

- Answer! 
    용자 명은 같지만 호스트가 달라서 다른 계정으로 파악합니다.
    MySQL은 접속해서 들어오는 클라이언트 호스트를 기준으로 계정을 매칭해요!

    mysql -u dev_user -p -h 127.0.0.1
    → MySQL은 dev_user + 127.0.0.1에 맞는 계정을 찾음
    → 'dev_user'@'127.0.0.1' 계정 사용합니다.

    mysql -u dev_user -p -h localhost (또는 호스트 생략하고 접속 시)
    → 보통 localhost로 인식됨
    → 'dev_user'@'localhost' 계정 사용합니다

---

# 3. 시스템 계정 vs 일반 계정

MySQL 8.0에서는 `SYSTEM_USER` 권한 유무에 따라 계정을 나눈다.

## 3-1. 시스템 계정 (SYSTEM_USER 권한 O)

- 다른 사용자 계정 생성/수정/삭제 가능
- 다른 세션(커넥션) 또는 그 세션에서 실행 중인 쿼리 강제 종료 가능
- 스토어드 프로그램의 DEFINER를 다른 사용자로 설정 가능

즉, **관리자(DBA)급 계정**이다.

## 3-2. 일반 계정

- 주로 `SELECT`, `INSERT`, `UPDATE`, `DELETE` 같은 데이터 작업만 하게 되는 계정
- 계정 관리, 세션 강제 종료 같은 “관리자 기능”은 불가

## 3-3. MySQL 기본 내장 계정

설치하면 MySQL 내부용 계정이 몇 개 자동으로 있다. 예:

- `'mysql.sys'@'localhost'`
    
    → sys 스키마 객체의 DEFINER
    
- `'mysql.session'@'localhost'`
    
    → 플러그인이 서버에 접근할 때 사용하는 계정

-Question? 플러그인이 서버에 접근할 때 사용하는 계정에 이름 붙이는 규칙이 있나요?
-Answer! 공식적인 규칙은 없지만 'plugin명_전용계정',
    '서비스/애플리케이션 prefix(app_, svc_, plg_ etc) + 역할' 으로
    진행합니다.
    
- `'mysql.infoschema'@'localhost'`
    
    → information_schema 뷰들의 DEFINER
    

이들은 **내부용** 계정이라, 건드리지 않고 두면 된다.

---

# 4. 계정 생성: `CREATE USER` 옵션 해석

MySQL 8.0에서는

- **계정 생성**: `CREATE USER`
- **권한 부여**: `GRANT`

이렇게 분리해서 사용하는 것이 기본이다.

예시:

```sql
CREATE USER 'user'@'%'
  IDENTIFIED WITH 'mysql_native_password' BY 'password'
  REQUIRE NONE
  PASSWORD EXPIRE INTERVAL 30 DAY
  ACCOUNT UNLOCK
  PASSWORD HISTORY DEFAULT
  PASSWORD REUSE INTERVAL DEFAULT
  PASSWORD REQUIRE CURRENT DEFAULT;

```

옵션 하나씩 해석해 보자.

---

## 4-1. `IDENTIFIED WITH ... BY ...` – 인증 방식 + 비밀번호

```sql
IDENTIFIED WITH 'mysql_native_password' BY 'password'

```

- **어떤 인증 플러그인**을 쓸지 + **비밀번호** 설정.
- MySQL 8.0 기본은 `caching_sha2_password`인데,
- 예전 클라이언트와 호환을 위해 `mysql_native_password`를 명시적으로 쓰는 경우도 있다.

백엔드에서 흔한 문제:

- 서버: MySQL 8.0 (기본 `caching_sha2_password`)
- JDBC 드라이버: 오래된 버전

→ 인증 플러그인 미지원 에러 발생 → 드라이버를 최신으로 올리거나 계정을 `mysql_native_password`로 만들기도 한다.

---

## 4-2. `REQUIRE` – SSL/TLS(암호화) 강제 여부

```sql
REQUIRE NONE

```

- 클라이언트가 서버에 접속할 때 **암호화(SSL/TLS)를 강제할지** 설정.
- `REQUIRE NONE`
    - 암호화 없이도 접속 허용 (기본)

운영 환경에선 보안 때문에 SSL/TLS를 켜고, 특정 인증서로만 접속 허용하는 설정을 쓰기도 한다.

- Question? SSL과 TLS가 어떤 암호화 방식인가요?
- Answer! 
SSL은 TLS의 하위버전으로 현재는 폐기된 프로토콜입니다.
SSL/TLS라고 부르는게 관행적으로 사용되어 문서에 해당 방식으로 작성한 것 입니다

SSL의 기본적 뼈대는 클라이언트-서버 간 데이터를 안전하게 전송하기 위한 보안통신 프로토콜입니다.
비대칭 암호화(RAS), 대칭키 암호화(AES), 무결성검증(AEAD)을 조합하여 사용합니다.

---

## 4-3. `PASSWORD EXPIRE` – 비밀번호 유효 기간

```sql
PASSWORD EXPIRE INTERVAL 30 DAY

```

- 비밀번호를 **얼마 동안만 유효하게 할지** 설정.

- Question? 계정 생성 후 바로 만료 상태 이면, 첫번째 로그인 시 비밀번호를 변경하는 것 일까요?
아니면 매번 로그인 할 때, 다음에 사용할 비밀번호를 변경하는 것 일까요?

보통 어떤 계정에서 PASSWORD EXPIRE를 사용하나요?

- Answer! PASSWORD EXPIRE을 '첫 로그인에서 한번만 비밀번호 변경을 강제하는 기능'으로 생각하시면 됩니다.

계정 생성 후 바로 만료가 된다면 로그인은 성공하지만 즉시 새 비밀번호를 설정하게 하고
새 비밀번호를 설정하면 만료상태가 해제됩니다.

PASSWORD EXPIRE은 신규 사용자 계정, 보안 규정이 있는 기업 환경(금융사에서는 30일마다 비밀번호는 바꾸는 정책이 있습니다. 이때 PASSWORD EXPIRE INTERVAL과 동시에 사용합니다)



종류:

- `PASSWORD EXPIRE`
    - 계정 생성 후 바로 만료 상태 (로그인 시 비밀번호 변경 강제)
- `PASSWORD EXPIRE NEVER`
    - 만료 기간 없음
- `PASSWORD EXPIRE DEFAULT`
    - 시스템 변수 `default_password_lifetime` 값 사용
- `PASSWORD EXPIRE INTERVAL n DAY`
    - n일 동안만 유효 (예: 30일)

개인 공부/로컬 환경: `NEVER`로 둬도 무방

운영 환경: 회사 보안 정책에 맞춰 30일, 90일 등으로 설정

-Question? 전에 쓰던 비밀번호를 DB가 있는 로컬에 모아 파일로 관리하나요?
-Answer! MySQL은 과거의 비밀번호의 해시값을 내부 시스템 테이블에 저장해두고 이번에 설정하는 해시값이 같은지 비교만 진행합니다.

---

## 4-4. `PASSWORD HISTORY` – 예전 비밀번호 재사용 제한

```sql
PASSWORD HISTORY DEFAULT

```

- “전에 쓰던 비밀번호를 다시 쓰지 못하게” 막는 기능.

종류:

- `PASSWORD HISTORY DEFAULT`
    - 시스템 변수 `password_history` 값 사용
- `PASSWORD HISTORY n`
    - 최근 n개 비밀번호는 재사용 금지

---

## 4-5. `PASSWORD REUSE INTERVAL` – 예전 비밀번호, 언제부터 다시 써도 되는지

```sql
PASSWORD REUSE INTERVAL DEFAULT

```

- “예전 비밀번호를 **얼마 후부터** 다시 쓸 수 있는지” 설정.

종류:

- `PASSWORD REUSE INTERVAL DEFAULT`
    - 시스템 변수 `password_reuse_interval` 값 사용
- `PASSWORD REUSE INTERVAL n DAY`
    - n일이 지나야 예전 비밀번호 재사용 가능

---

## 4-6. `PASSWORD REQUIRE` – 비밀번호 변경 시 현재 비번 요구 여부

```sql
PASSWORD REQUIRE CURRENT DEFAULT;

```

- 비밀번호 변경 시 **현재 비밀번호 입력을 요구할지** 결정.

종류:

- `PASSWORD REQUIRE CURRENT`
    - 반드시 현재 비밀번호 입력
- `PASSWORD REQUIRE OPTIONAL`
    - 현재 비번 없이도 변경 가능
- `PASSWORD REQUIRE DEFAULT`
    - 시스템 변수 `password_require_current` 값 사용

---

## 4-7. `ACCOUNT LOCK / UNLOCK` – 계정 잠금/해제

```sql
ACCOUNT UNLOCK

```

- 계정을 **잠글지/풀지** 설정.

옵션:

- `ACCOUNT LOCK`
    - 계정 잠금 (로그인 불가)
- `ACCOUNT UNLOCK`
    - 계정 활성 (로그인 가능)

실무 예시:

- 퇴사자 계정: `ACCOUNT LOCK`
- 잠깐 쓰지 않을 테스트 계정 잠금 후 필요 시 `UNLOCK`

---

# 5. 비밀번호 정책: `validate_password` 컴포넌트

MySQL에는 비밀번호가 너무 허술하지 않도록 검사해 주는 **validate_password** 컴포넌트가 있다.

## 5-1. 설치

```sql
INSTALL COMPONENT 'file://component_validate_password';

```

설치 후, 비밀번호 정책 관련 시스템 변수를 사용할 수 있다.

## 5-2. 정책 수준(LOW / MEDIUM / STRONG)

기본값은 보통 `MEDIUM`.

- `LOW`
    - 길이만 검사 (예: 8자 이상)
- `MEDIUM`
    - 길이 + 숫자 + 대문자 + 소문자 + 특수문자 조합 검사
- `STRONG`
    - MEDIUM 기준 + **금칙어(사전)** 검사까지

## 5-3. 금칙어 사전 + 정책 설정 예

```sql
SET GLOBAL validate_password.dictionary_file = 'prohibitive_word.data';
SET GLOBAL validate_password.policy = 'STRONG';

```

- `prohibitive_word.data` 파일에 비밀번호에 포함되면 안 되는 단어들을 넣어두고,
- STRONG 정책으로 설정하면 이 단어가 포함된 비밀번호는 사용할 수 없다.

운영 환경에서는 보안 정책에 맞게 이 값을 강하게 설정하고,

개인 공부 환경에서는 크게 신경 안 써도 된다.

---

# 6. 이중 비밀번호(Dual Password)

문제 상황:

- 서비스용 DB 계정 비밀번호를 변경해야 하는데,
- 애플리케이션 서버 여러 대가 모두 이 비밀번호를 쓰고 있음.
- 한 번에 다 바꾸기 어렵고, 타이밍이 어긋나면 서비스 장애 발생.

해결책: **이중 비밀번호**

- 한 계정에 **Primary 비밀번호 + Secondary 비밀번호** 2개를 둘 수 있다.
- 일정 기간 동안은 **두 비밀번호 모두 유효**하게 하여,
    - 애플리케이션 서버 설정을 순차적으로 변경
    - 전부 새 비번으로 바꾸고 나면 Secondary 삭제

비밀번호 변경 명령에 `RETAIN CURRENT PASSWORD` 옵션 등을 사용해

현재 비밀번호를 Secondary로 남겨 두는 방식이다.

실무에서의 사용 흐름:

1. 새 비밀번호를 Primary로 설정 + 기존 비밀번호는 Secondary로 유지
2. 애플리케이션 서버 설정을 하나씩 새 비번으로 교체
3. 모든 서버가 새 비번을 쓰게 되면 Secondary 비번 제거

보안상 Secondary 비밀번호는 영원히 두지 않고,

마이그레이션이 끝나면 삭제하는 것이 좋다.

---

# 7. 권한(Privileges)과 `GRANT`

사용자가 **무엇을 할 수 있는지**를 결정하는 것이 권한(Privilege)이다.

대표적인 권한 예:

- `SELECT` : 조회
- `INSERT` : 행 추가
- `UPDATE` : 행 수정
- `DELETE` : 행 삭제
- `CREATE` : 테이블/DB 생성
- `DROP` : 테이블/DB 삭제

기본 원칙:

- **애플리케이션용 계정**에는
    - 진짜 필요한 DB/테이블에
    - 필요한 권한만 최소로 (`SELECT`, `INSERT`, `UPDATE`, `DELETE` 정도)
- `CREATE`, `DROP` 같은 스키마 변경은
    - DBA/관리자 계정에서만 수행

예시:

```sql
GRANT SELECT, INSERT, UPDATE, DELETE
ON myapp.*
TO 'app_user'@'서버IP';

```

---

# 8. 역할(Role): 여러 권한을 묶어서 관리

MySQL 8.0에서는 여러 권한을 묶어 **역할(Role)** 로 만들고,

사용자에게는 이 Role을 할당하는 방식으로 관리할 수 있다.

예시:

```sql
-- 1) 역할 생성
CREATE ROLE
  role_emp_read,
  role_emp_write;

-- 2) 역할에 권한 부여
GRANT SELECT ON employees.* TO role_emp_read;
GRANT INSERT, UPDATE, DELETE ON employees.* TO role_emp_write;

-- 3) 사용자 생성
CREATE USER 'reader'@'127.0.0.1' IDENTIFIED BY 'qwerty';
CREATE USER 'writer'@'127.0.0.1' IDENTIFIED BY 'qwerty';

-- 4) 역할을 사용자에게 부여
GRANT role_emp_read TO 'reader'@'127.0.0.1';
GRANT role_emp_read, role_emp_write TO 'writer'@'127.0.0.1';

```

의미:

- `role_emp_read`
    
    → `employees` 스키마 읽기 전용 권한 묶음
    
- `role_emp_write`
    
    → `employees` 스키마 쓰기 권한 묶음
    
- `reader`
    
    → 읽기 전용
    
- `writer`
    
    → 읽기 + 쓰기 모두 가능
    

장점:

- 사람(직원)이 부서/역할이 바뀔 때
    - 권한 하나하나 다시 GRANT/Revoke 하는 대신
    - **어떤 Role을 줄지/뺄지만 관리**하면 된다.

## 8-1. 로그인 시 역할 자동 활성화

로그인할 때마다 `SET ROLE` 명령으로 역할을 활성화해도 되지만,

아예 전역 설정으로 **로그인 시 모든 역할이 자동으로 활성**되게 할 수도 있다.

```sql
SET GLOBAL activate_all_roles_on_login = ON;

```

---

# 9. 한 페이지 요약

1. **사용자 식별**
    - `'user'@'host'` 형식으로 아이디 + 접속 호스트(IP)까지 포함해서 계정 구분
2. **계정 종류**
    - `SYSTEM_USER` 권한이 있는 시스템 계정(관리자)
    - 일반 계정(데이터 작업 위주)
3. **계정 생성**
    - `CREATE USER`로 계정 만들고
    - `GRANT`로 권한 부여 (MySQL 8.0 표준 방식)
4. **비밀번호 관련 옵션**
    - `IDENTIFIED WITH … BY …` : 인증 플러그인 + 비밀번호
    - `REQUIRE` : SSL/TLS 사용 강제 여부
    - `PASSWORD EXPIRE` : 비밀번호 유효 기간
    - `PASSWORD HISTORY` / `PASSWORD REUSE INTERVAL` : 비밀번호 재사용 제한
    - `PASSWORD REQUIRE CURRENT` : 비밀번호 변경 시 현재 비밀번호 요구 여부
    - `ACCOUNT LOCK/UNLOCK` : 계정 잠금/해제
5. **비밀번호 정책 컴포넌트**
    - `validate_password` 설치 후 LOW / MEDIUM / STRONG 정책, 금칙어 사전 설정 가능
6. **이중 비밀번호**
    - Primary + Secondary 비번 두 개를 동시에 두고, 무중단으로 비번 교체 가능
7. **권한 & 역할**
    - `GRANT`로 개별 권한 부여
    - 여러 권한을 Role로 묶어 `CREATE ROLE`, `GRANT role TO user` 방식으로 관리
    - `activate_all_roles_on_login = ON` 으로 로그인 시 역할 자동 활성화

---