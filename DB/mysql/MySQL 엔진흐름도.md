# MySQL 엔진 정리

**1) MySQL 서버의 전체 큰 그림**

- MySQL 서버는 크게 **MySQL 엔진(두뇌)** 과 **스토리지 엔진(디스크 I/O 담당)** 으로 나뉜다.
- MySQL 엔진은 **접속 처리(커넥션 핸들러)**, **SQL 파싱/전처리**, **옵티마이저** 중심으로 쿼리를 “어떻게 실행할지”를 결정한다.
- 스토리지 엔진은 **데이터를 디스크에 저장/읽기**를 수행하고, 테이블마다 스토리지 엔진을 지정하며 여러 엔진을 동시에 쓸 수 있다.

---

## **2) Handler API (MySQL 엔진 ↔ 스토리지 엔진 연결부)**

- MySQL 실행기가 스토리지 엔진에게 **읽기/쓰기 요청**을 보내는 통로가 핸들러 요청(Handler request)이고, 그때 쓰는 인터페이스가 **Handler API**다.
- 즉 “옵티마이저/실행기”는 스토리지 엔진 내부 구현을 직접 만지지 않고, **핸들러 API로만** 데이터를 가져오고 쓴다(구조적 분리의 핵심).

---

## **3) 스레딩 구조 (Foreground vs Background)**

### **3-1. 포그라운드 스레드(= 클라이언트 스레드)**

- 최소 **접속한 클라이언트 수만큼** 존재하며, 각 클라이언트의 쿼리를 처리한다.
- 커넥션 종료 시 스레드는 **스레드 캐시**로 돌아가며, 캐시가 충분히 차 있으면 종료된다.
- 데이터는 **버퍼/캐시에서 우선 조회**, 없으면 디스크에서 읽어온다.

### **3-2. 백그라운드 스레드(특히 InnoDB에서 중요)**

- InnoDB는 여러 작업을 백그라운드로 처리(예: 인서트 버퍼 병합, 로그 디스크 기록, 버퍼풀 flush, read-ahead/읽기, 락/데드락 모니터링 등).
- 글에서는 특히 **로그 기록 스레드**와 **버퍼→디스크 쓰기 스레드**를 중요 포인트로 잡는다.
- 차이점: **MyISAM은 디스크 쓰기까지 포그라운드가 처리**하지만, **InnoDB는 버퍼까지만 포그라운드가 처리하고 디스크 반영은 백그라운드가 담당**한다.

---

## **4) 메모리 할당 구조 (Global vs Local)**

### **4-1. 글로벌 메모리 영역 (서버 전체 공유)**

- MySQL이 실행되며 OS로부터 할당되고, 스레드 수와 무관하게(필요 시 여러 덩어리일 수는 있지만) **전체 스레드가 공유**한다.
- 예시: **테이블 캐시**, **InnoDB 버퍼 풀**, **어댑티브 해시 인덱스**, **리두 로그 버퍼**

### **4-2. 로컬 메모리 영역 (세션/커넥션 단위)**

- 클라이언트 스레드가 쿼리 처리에 쓰는 메모리로, **스레드별 독립**이며 공유되지 않는다.
- 필요할 때만 잡히는 대표 예가 **소트 버퍼/조인 버퍼**(쿼리 시점에 할당 후 해제)이고, **커넥션/결과 버퍼는 세션 유지 동안 계속** 잡혀 있을 수 있다.
- 예시: 정렬 버퍼, 조인 버퍼, 바이너리 로그 캐시, 네트워크 버퍼

---

## **5) 플러그인 스토리지 엔진 모델 + 컴포넌트**

### **5-1. 플러그인 모델**

- MySQL의 특징적 구조로, 스토리지 엔진뿐 아니라 **전문 검색용 검색어 파서**, **인증(Native / Caching SHA-2)** 같은 기능도 플러그인으로 제공될 수 있다고 설명한다.
- 필요하면 스토리지 엔진 자체를 “추가 개발”해 붙이는 것도 가능하다고 언급한다.

### **5-2. 컴포넌트(Component) 아키텍처 (MySQL 8.0+)**

- 8.0부터는 기존 플러그인의 한계를 보완하려고 **컴포넌트 아키텍처**를 지원한다.
- 플러그인 한계로는 (1) 플러그인 간 통신/인터페이스 제약, (2) 서버 변수/함수 직접 호출로 인한 안전성 문제(캡슐화 부족), (3) 의존 관계 설정 어려움으로 초기화 난이도 등을 든다.

---

## **6) 쿼리 실행 구조 (Parser → Preprocessor → Optimizer → Execution → Handler)**

### **6-1. 단계별 역할**

1. **쿼리 파서**: SQL을 토큰으로 쪼개 트리 구조로 만들고, 문법 오류를 여기서 잡는다.
2. **전처리기**: 파서 트리를 기반으로 객체(테이블/컬럼/함수) 매핑, 존재 여부/권한 확인 등 “구조적 문제”를 점검한다.
3. **옵티마이저**: 가장 저렴한 비용으로 빠르게 처리할 실행 계획을 선택한다.
4. **실행 엔진(쿼리 실행기)**: 옵티마이저가 만든 계획대로 **핸들러에 작업을 시키고 결과를 전달**한다.
5. **핸들러(= 스토리지 엔진)**: 실행 엔진 요청에 따라 디스크에 저장/읽기를 수행하며, InnoDB/MyISAM 등 “실제 엔진”이 된다.

### **6-2. 실행 흐름 예시**

- 실행 엔진이 핸들러에 임시 테이블 생성 → 조건 레코드 읽기 → 임시 테이블 저장 → 임시 테이블에서 결과 읽기 → 결과 반환 흐름을 예로 든다.
- GROUP BY / ORDER BY 같은 복잡 처리는 스토리지 엔진이 아니라 **MySQL 엔진(쿼리 실행기) 영역**에서 처리된다고 정리한다.