# 5장

## **1. 트랜잭션(Transaction)**

- 여러 작업을 **하나의 논리적 단위**로 묶어 모두 성공(commit) 또는 모두 실패(rollback)로 처리.
- 목적: **데이터 정합성 유지**, 부분 업데이트 방지.
- **트랜잭션 지원 엔진: InnoDB**
    
    MyISAM, MEMORY 등은 미지원 → 부분적 반영 가능.
    

### **🔎 핵심 요소**

- **ACID**
    - Atomicity(원자성), Consistency(일관성), Isolation(격리성), Durability(지속성)
- 
- **주의점**
    - 트랜잭션은 **짧게 유지**해야 락/커넥션 점유 문제 방지.
    - 조회, 파일 I/O, 외부 API 호출 등은 트랜잭션 범위 밖으로 분리.
- 

---

## **2. 락(Lock) — 동시성 제어 핵심**

MySQL의 잠금은 **엔진 레벨**과 **스토리지 엔진(InnoDB) 레벨**로 구분된다.

---

## **2-1. MySQL 엔진 레벨 락**

**2-1. MySQL 엔진 레벨 락**

| **락 종류** | **특징** |
| --- | --- |
| **글로벌 락 (Global Lock)** | 전체 DB 읽기 전용 상태. 백업/스냅샷 용도. 영향 매우 큼. |
| **백업 락 (Backup Lock)** | DDL·계정 관리 등은 차단 / DML 허용. Global Lock보다 가벼움. |
| **테이블 락 (Table Lock)** | 특정 테이블 전체를 잠금. MyISAM에서 많이 사용됨. |
| **네임드 락 (Named Lock)** | 문자열 기반 사용자 정의 락. 여러 클라이언트 간 동기화 용도. |
| **메타데이터 락 (MDL)** | 테이블 구조 변경(DDL) 시 자동 획득. SELECT와 DDL 간 충돌 방지. |

네임드락,테이블락만 사용자가 직접 락을 지정할 수 있습니다. 
(이외에는 MySQL에서 자동으로 걸어집니다.)

네임드락은 아래와 같은 방식으로 지정합니다.
SELECT GET_LOCK('내가_원하는_락의_이름', timeout);
'내가_원하는_락의_이름' 부분이 사용자가 지정하는 부분이고 이게 락의 식별자입니다.

테이블락은 아래와 같이 직접 사용자가 걸 수 있습니다.
LOCK TABLES table_name WRITE;
UNLOCK TABLES;
---

**2-2. InnoDB 스토리지 엔진 레벨 락**

| **락 종류** | **특징** |
| --- | --- |
| **레코드 락 (Record Lock)** | 인덱스 기반 개별 레코드 잠금 → 동시성 우수. |
| **갭 락 (Gap Lock)** | 레코드 사이의 ‘공백’ 잠금 → 신규 Insert 방지. |
| **넥스트 키 락 (Next-Key Lock)** | 레코드 락 + 갭 락. Phantom Read 방지. |
| **AUTO_INCREMENT 락** | 자동 증가 값 충돌 방지. MySQL 8.0 기본 모드는 경량화(Latch 기반). |

사용자가 직접 설정할 수 있는 엔진 레벨의 락은 없습니다.
레코드 락 / 갭 락 / 넥스트키 락 / AUTO_INCREMENT 락은
모두 MySQL(InnoDB)이 “자동으로” 거는 락입니다

그렇다면 사용자가 직접 걸 수 있는 락은 뭐였지?

이건 스토리지 엔진 레벨 락이 아니라
앞서 말한 MySQL 엔진 레벨에서만 가능합니다(네임드락, 테이블락)

### **⚠ 실무 주의사항**

- **인덱스가 없으면 → 더 넓은 범위 락 발생(테이블 대부분 락)**
- **데드락**은 자연스러운 현상 → 트랜잭션 최소화 + 접근 순서 일관성 필요.

---

## **3. 격리 수준(Isolation Level)**

트랜잭션 간 간섭을 어느 수준까지 허용할지 결정.

| **격리 수준** | **허용 현상** | **설명** |
| --- | --- | --- |
| READ UNCOMMITTED | Dirty Read | 커밋 전 데이터 읽힘. 가장 낮은 격리. |
| READ COMMITTED | Non-repeatable Read | Oracle 등에서 기본. 커밋된 최신 값 읽음. |
| REPEATABLE READ (InnoDB 기본) | 없음 | 동일 트랜잭션 내 조회 결과 고정. Gap/Next-Key Lock로 Phantom Read도 방지. |
| SERIALIZABLE | 없음 | 가장 엄격. 읽기도 락 필요. 성능 저하 큼. |

### **⚠ 실무 권장**

- **InnoDB + REPEATABLE READ(기본 설정)** → 대부분 서비스에서 충분한 정합성 & 높은 동시성

(실제 프로젝트 예시)

상황 : 사용자가 지역 이미지,영상,문서를 업로드 하면 
Web > Proxy > MinIO > Airflow > PostgreSQL로 전달되는 파이프라인을 구축했습니다.

이때 웹에서 동시에 여러 사용자가 같은 지역 코드(region_code)로 메타데이터를 삽입할 수 있습니다.

트랙잭션 격리 수준이 낮으면 
사용자 A와 B가 같은 지역 코드로 SELECT를 동시에 진행하면 둘 다 존재하지 않는다고 판단합니다.
두 명 모두 동시에 INSERT를 진행해도 중복데이터, 무결성이 깨집니다.

이때, InnoDB + REPEATABLE READ가 해겷라는 부분이
같은 트랙잭션 내에서 반복해서 SELECT를 하는 경우
데이터 스냅샷이 유지되어 phantom read 방지를 진행합니다.

즉,
	1.	사용자 A가 SELECT로 지역 코드를 확인
	2.	그동안 B가 INSERT를 시도하더라도
	3.	A 트랜잭션에서는 보이지 않음(스냅샷 유지)
	4.	A 트랜잭션이 끝나는 시점에 INSERT 시 충돌 감지 및 오류 처리
  
→ 중복 삽입이나 Dirty Read 없이 정합성 유지가 가능합니다.

---

## **4. 성능·운영 측면 핵심 요약**

- **트랜잭션은 짧고 명확하게**: 긴 트랜잭션 = 데드락·락 대기·슬로우 쿼리 원인.
- **인덱스 기반 접근 필수**: UPDATE/DELETE 시 특히 중요.
- **자동 증가 락 전략 확인**: 동시 INSERT 많은 테이블에서 성능 영향 있음.
- **잠금 모니터링**: performance_schema.data_locks, data_lock_waits 활용.
- **DDL과 DML 충돌 주의(MDL)**: 운영 환경에서 스키마 변경 시 세심한 계획 필요.


## **5장 추가내용 정리 **

# 📌 **5-1. InnoDB 트랜잭션 내부 구조 
(Undo / Redo / MVCC)**

## **1) Undo Log – 변경되기 전 데이터를 보관**

- UPDATE·DELETE와 같은 변경 작업이 실행되면
    
    기존 데이터의 사본을 Undo Log에 저장한다.
    
- **Rollback**은 이 Undo Log를 기반으로 이전 상태로 되돌림.
- *MVCC(다중 버전 동시성 제어)**의 스냅샷 읽기가
    
    Undo Log의 version chain(버전 체인)을 기반으로 구현됨.
    

### ⭐ Undo Log가 필요한 이유

- Rollback을 가능하게 함 → 원자성(Atomicity)
- 트랜잭션의 시점별 데이터를 읽게 함 → 격리성(Isolation)
- SELECT 시 항상 “변경 이전 버전”을 제공 → 일관된 읽기(Consistent Read)

---

## **2) Redo Log – 영속성(Durability) 보장**

- InnoDB는 변경 내용을 버퍼 풀(Buffer Pool)에 먼저 기록하고
    
    실제 디스크 반영은 나중에 이루어진다.
    
- 시스템 장애가 발생해도 Redo Log를 기반으로
    
    변경 내용을 다시 적용할 수 있음.
    

### ⭐ Redo Log의 목적

- 커밋 = 즉시 디스크 반영이 *아님*
- 커밋은 Redo Log에 기록되었다는 의미
- 이후 InnoDB의 background flush 스레드가 실제 데이터 파일로 동기화

→ 이 덕분에 MySQL이 매우 빠른 쓰기 성능을 유지하면서 안정성도 확보함.

---

## **3) MVCC(Multi-Version Concurrency Control)**

- InnoDB는 트랜잭션마다 **Read View**라는 스냅샷을 생성한다.
- SELECT는 실제 최신 데이터가 아니라
    
    **Undo Log에 보관된 ‘트랜잭션 시점의 버전’**을 읽는다.
    
- 이로 인해 REPEATABLE READ 격리 수준에서
    
    동일 SELECT 결과가 항상 동일하게 유지된다.
    

### ⭐ 핵심

> MVCC 덕분에 SELECT는 락을 걸지 않고도
> 
> 
> 일관된 데이터를 읽을 수 있다.
> 

---

# 📌 **5-2. Gap Lock / Next-Key Lock 동작 방식 상세 설명**

## **1) Record Lock = 특정 레코드에 대한 락**

WHERE 조건으로 정확히 특정 PK/Unique 값을 찾을 때 주로 걸림.

---

## **2) Gap Lock = 레코드 사이의 "빈 공간" 잠금**

예:

```sql
SELECT * FROM user WHERE age BETWEEN 20 AND 29 FOR UPDATE;

```

- 20~29 사이의 실제 레코드뿐 아니라
- 20 < x < 29 범위의 **삽입을 막기 위한 공간에 락이 걸림**

### ⭐ 목적

- Phantom Read 방지
- 중복 삽입 방지

---

## **3) Next-Key Lock = Record + Gap Lock**

InnoDB의 기본 락 방식.

검색된 레코드 + 그 앞의 Gap 부분까지 포함하여 락을 건다.

### ⭐ 중요한 포인트

- 인덱스가 없으면 → 테이블 대부분에 Gap Lock이 걸림(성능 저하)
- REPEATABLE READ에서 **Phantom Read가 방지되는 이유**

---

# 📌 **5-3. 트랜잭션 격리 수준별 “잠금 전략 차이”**

스펙상 격리 수준과 실제 MySQL/InnoDB의 동작이 다를 수 있음.

## **1) READ COMMITTED**

- 매 SELECT마다 새로운 Read View 생성
- Gap Lock 거의 없음 → 동시성 높음
- UPDATE/DELETE 시 필요한 레코드만 잠금

---

## **2) REPEATABLE READ (InnoDB 기본)**

- 트랜잭션 시작 시점 기준 스냅샷 유지
- Gap Lock / Next-Key Lock 활성화
- Phantom Read 방지

---

## **3) SERIALIZABLE**

- SELECT조차 잠금을 동반
- 동시성 매우 낮음
- 일반 서비스에서는 거의 쓰지 않음

---

## ⭐ 정리

| 격리 수준 | Gap Lock | Phantom Read | 특징 |
| --- | --- | --- | --- |
| READ COMMITTED | 거의 없음 | 발생 가능 | 동시성 우수 |
| REPEATABLE READ | 있음 | 방지 | InnoDB 기본, 가장 균형 잡힘 |
| SERIALIZABLE | 있음(읽기도 락) | 방지 | 동시성 최악 |

---

# 📌 **5-4. Implicit Commit(자동 커밋) 발생 명령**

MySQL은 아래 명령들이 실행되면

트랜잭션 중이더라도 **즉시 commit을 발생시킨다.**

## **DDL 명령**

- CREATE
- ALTER
- DROP
- TRUNCATE
- RENAME TABLE

## **기타 명령**

- LOCK TABLES
- UNLOCK TABLES
- ANALYZE TABLE
- GRANT / REVOKE

### ⭐ 실수하는 대표적인 케이스

트랜잭션 안에서 아래처럼 하면 트랜잭션이 **깨짐**:

```sql
START TRANSACTION;

UPDATE member SET age = age + 1;
ALTER TABLE member ADD COLUMN tmp INT;  -- ❌ 자동 COMMIT 발생

ROLLBACK;  -- 이미 무의미함

```

---

# 📌 **5-5. 데드락(Deadlock)이 발생하는 이유와 내부 처리 방식**

## **1) 데드락이란?**

두 트랜잭션이 서로가 가진 락을 기다리면서

영원히 대기 상태에 빠지는 상황.

---

## **2) 왜 자연스럽게 발생하는가?**

- UPDATE 또는 SELECT … FOR UPDATE의 접근 순서가 다르면 동일 테이블에서도 발생
- 인덱스가 없으면 더 넓은 영역을 잠가 데드락 확률 증가
- 동시성이 높은 시스템일수록 당연히 자주 발생

---

## **3) InnoDB의 데드락 처리 방식**

InnoDB는 주기적으로 **wait-for graph**를 분석하여

루프가 발생하면 즉시 데드락을 감지하고 한 트랜잭션을 죽인다.

### Victim 선정 기준:

- 더 적은 비용(undo log가 작은 트랜잭션)이 희생됨
- 오래 기다린 트랜잭션도 우선 희생될 수 있음

---

## **4) 데드락 방지 실전 팁**

- 트랜잭션 실행 시간 최소화
- 동일한 테이블 접근 순서 통일
- 인덱스 최적화
- SELECT … FOR UPDATE 범위 최소화
- Batch 업데이트는 작은 단위로 쪼개기