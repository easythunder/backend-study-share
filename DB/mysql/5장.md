# 5장

## **1. 트랜잭션(Transaction)**

- 여러 작업을 **하나의 논리적 단위**로 묶어 모두 성공(commit) 또는 모두 실패(rollback)로 처리.
- 목적: **데이터 정합성 유지**, 부분 업데이트 방지.
- **트랜잭션 지원 엔진: InnoDB**
    
    MyISAM, MEMORY 등은 미지원 → 부분적 반영 가능.
    

### **🔎 핵심 요소**

- **ACID**
    - Atomicity(원자성), Consistency(일관성), Isolation(격리성), Durability(지속성)
- 
- **주의점**
    - 트랜잭션은 **짧게 유지**해야 락/커넥션 점유 문제 방지.
    - 조회, 파일 I/O, 외부 API 호출 등은 트랜잭션 범위 밖으로 분리.
- 

---

## **2. 락(Lock) — 동시성 제어 핵심**

MySQL의 잠금은 **엔진 레벨**과 **스토리지 엔진(InnoDB) 레벨**로 구분된다.

---

## **2-1. MySQL 엔진 레벨 락**

**2-1. MySQL 엔진 레벨 락**

| **락 종류** | **특징** |
| --- | --- |
| **글로벌 락 (Global Lock)** | 전체 DB 읽기 전용 상태. 백업/스냅샷 용도. 영향 매우 큼. |
| **백업 락 (Backup Lock)** | DDL·계정 관리 등은 차단 / DML 허용. Global Lock보다 가벼움. |
| **테이블 락 (Table Lock)** | 특정 테이블 전체를 잠금. MyISAM에서 많이 사용됨. |
| **네임드 락 (Named Lock)** | 문자열 기반 사용자 정의 락. 여러 클라이언트 간 동기화 용도. |
| **메타데이터 락 (MDL)** | 테이블 구조 변경(DDL) 시 자동 획득. SELECT와 DDL 간 충돌 방지. |

네임드락,테이블락만 사용자가 직접 락을 지정할 수 있습니다. 
(이외에는 MySQL에서 자동으로 걸어집니다.)

네임드락은 아래와 같은 방식으로 지정합니다.
SELECT GET_LOCK('내가_원하는_락의_이름', timeout);
'내가_원하는_락의_이름' 부분이 사용자가 지정하는 부분이고 이게 락의 식별자입니다.

테이블락은 아래와 같이 직접 사용자가 걸 수 있습니다.
LOCK TABLES table_name WRITE;
UNLOCK TABLES;
---

**2-2. InnoDB 스토리지 엔진 레벨 락**

| **락 종류** | **특징** |
| --- | --- |
| **레코드 락 (Record Lock)** | 인덱스 기반 개별 레코드 잠금 → 동시성 우수. |
| **갭 락 (Gap Lock)** | 레코드 사이의 ‘공백’ 잠금 → 신규 Insert 방지. |
| **넥스트 키 락 (Next-Key Lock)** | 레코드 락 + 갭 락. Phantom Read 방지. |
| **AUTO_INCREMENT 락** | 자동 증가 값 충돌 방지. MySQL 8.0 기본 모드는 경량화(Latch 기반). |

### **⚠ 실무 주의사항**

- **인덱스가 없으면 → 더 넓은 범위 락 발생(테이블 대부분 락)**
- **데드락**은 자연스러운 현상 → 트랜잭션 최소화 + 접근 순서 일관성 필요.

---

## **3. 격리 수준(Isolation Level)**

트랜잭션 간 간섭을 어느 수준까지 허용할지 결정.

| **격리 수준** | **허용 현상** | **설명** |
| --- | --- | --- |
| READ UNCOMMITTED | Dirty Read | 커밋 전 데이터 읽힘. 가장 낮은 격리. |
| READ COMMITTED | Non-repeatable Read | Oracle 등에서 기본. 커밋된 최신 값 읽음. |
| REPEATABLE READ (InnoDB 기본) | 없음 | 동일 트랜잭션 내 조회 결과 고정. Gap/Next-Key Lock로 Phantom Read도 방지. |
| SERIALIZABLE | 없음 | 가장 엄격. 읽기도 락 필요. 성능 저하 큼. |

### **⚠ 실무 권장**

- **InnoDB + REPEATABLE READ(기본 설정)** → 대부분 서비스에서 충분한 정합성 & 높은 동시성

---

## **4. 성능·운영 측면 핵심 요약**

- **트랜잭션은 짧고 명확하게**: 긴 트랜잭션 = 데드락·락 대기·슬로우 쿼리 원인.
- **인덱스 기반 접근 필수**: UPDATE/DELETE 시 특히 중요.
- **자동 증가 락 전략 확인**: 동시 INSERT 많은 테이블에서 성능 영향 있음.
- **잠금 모니터링**: performance_schema.data_locks, data_lock_waits 활용.
- **DDL과 DML 충돌 주의(MDL)**: 운영 환경에서 스키마 변경 시 세심한 계획 필요.