# 스프링 DI

## DI

Dependency Injection, 의존 주입이라고 번역한다.  

### 의존

객체간의 의존을 의미한다.  
변경에 의해 영향을 받는 관례를 의미한다.  
예를 들어 한틀래스가 다른 클래스의 메서드를 실행 할때 의존한다고 표현한다.  

의존하는 대상을 구하는 방법  

1. 의존 대상 객체를 직접 생성  
2. DI와 로케이터


<details><summary><code>💡 피드백</code> : 의존 대상 객체를 직접 생성하는 방식의 장점과 단점이 궁금합니다.</summary>

장점은 외부 설정 없이 new로 객체를 생성하기 때문에 , 객체 생성 위치와 흐름을 코드에서 바로 확인할 수 있어 직관적이라는 점입니다.
단점은 구현 클래스에 직접 의존하는 강한 결합 구조가 되어, 구현체 변경 시 관련 코드를 모두 수정해야 한다는 점 입니다.  
또한 객체를 생성하는 코드가 여러 곳에 분산되면 중복이 늘어나고, 구현 클래스가 많아질 수록 관리와 확장이 어려워집니다.  
</details>
 
## DI를 통한 의존 처리 방법

1. 생성자 주입 방식
2. setter 메서드 방식

### 생성자 방식

빈 객체를 생성하는 시점에 완전한 상태의 객체를 사용할 수 있다.

### setter 메서드 방식

메서드 이름만으로 어떤 의존 객체를 설정하는지 쉽게 유추 가능하다.  
하지만 해당 객체를 사용할 시점에 의존 객체를 전달하지 않도 빈객체가 생성 되기 때문에 NullPointException이 발생할 수 있다.

<details><summary><code>💡 피드백</code> : setter 주입을 진행할때, 객체의 입장에서 NullPointerException 위험이 생기는 이유가 궁금합니다</summary>

setter 주입은 객체가 먼저 생성되고, 이후에 의존 객체가 주입됩니다.  
이 과정에서 setter 가 호출되지 않으면, 객체는 의존성이 없는 상태로 생성될 수 있습니다.  
컴파일 시점에서는 문제가 없지만 , 실행 중 의존 객체를 사용하는 순간 NullPointerException이 발생할 수 있습니다.  
반면 생성자 주입은 객체 생성 시점에 필요한 의존성을 반드시 전달 받도록 강제 함으로, 객체가 항상 완전한 상태로 생성됩니다.  

따라서 필수 의존성은 생성자 주입을 사용하고 선택적 의존성에는 setter 주입을 사용합니다.  

</details>

## assembler 조립기

객체를 생성해 주고 주입해주는 역할을 하는 클래스

## 스프링은 DI를 지원하는 조립기

## @Configuration
## @Autowired
## @Import

